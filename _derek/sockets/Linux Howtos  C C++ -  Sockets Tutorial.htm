<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0043)http://www.linuxhowtos.org/C_C++/socket.htm -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="content-language" content="en"><meta name="language" content="english, en"><meta name="generator" content="LeopardCMS Content Management System (www.LeopardCMS.com)"><meta name="robots" content="index,follow"><meta name="revisit-after" content="7 days"><link rel="alternate" type="application/rss+xml" title="RSS-Newsfeed" href="http://www.linuxhowtos.org/news.rss">
<link rel="alternate" type="application/rdf+xml" title="RDF-Newsfeed" href="http://www.linuxhowtos.org/news.rdf">
<link rel="alternate" type="application/atom+xml" title="Atom-Newsfeed" href="http://www.linuxhowtos.org/news.xml">
<link rel="meta" href="http://static.linuxhowtos.org/labels.rdf" type="application/rdf+xml" title="ICRA labels">
<meta http-equiv="pics-Label" content="(pics-1.1 &quot;http://www.icra.org/pics/vocabularyv03/&quot; l gen true for &quot;http://linuxhowtos.org&quot; r (n 0 s 0 v 0 l 0 oa 0 ob 0 oc 0 od 0 oe 0 of 0 og 0 oh 0 c 0) gen true for &quot;http://www.linuxhowtos.org&quot; r (n 0 s 0 v 0 l 0 oa 0 ob 0 oc 0 od 0 oe 0 of 0 og 0 oh 0 c 0))">
<title>Linux Howtos: C/C++ -&gt; Sockets Tutorial</title><style type="text/css" title="normalStyle">@import "http://static.linuxhowtos.org/css/blue.css";
@import "http://static.linuxhowtos.org/css/nonie.css";
.shadb { width:100%; }</style><script type="text/javascript" src="./Linux Howtos  C C++ -  Sockets Tutorial_files/interactive.js"></script>
<script type="text/javascript">//<!--
function onResize(){var w,h;if (window.innerWidth && window.innerHeight){w=window.innerWidth;h=window.innerHeight;}else if (document.body && document.body.offsetWidth){w=document.body.offsetWidth-5;height=document.body.offsetHeight-30;}bg=document.getElementById("background");if (bg){ browser=navigator.userAgent; if ((browser.indexOf("Firefox")>0 || browser.indexOf("BonEcho")>0) && browser.indexOf("Linux")>0)bg.style.display="none";else{bg.style.width=w+"px";bg.style.height=h+"px";}}}function bodyloaded() { window.onresize=onResize; onResize(); }  //--></script>
</head><body><div><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/bluefade.jpg" width="5" height="256" alt="" id="background" style="width: 1280px; height: 921px; "></div>
<div class="invisible"><a href="http://www.linuxhowtos.org/C_C++/socket.htm#contentlink" title="jump to the content">jump to the content</a></div><div id="main"><div class="inner"><table summary="header layout table"><tbody><tr><td class="bd" id="logo" colspan="2" rowspan="2"><span id="logotext">www.LinuxHowtos.org</span> howtos, tips&amp;tricks and tutorials for linux</td><td class="shadt"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/shadow-tr.png" width="18" height="18" alt=""></td></tr>
<tr><td class="shadr"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/blank.gif" height="18" width="18" alt=""></td></tr>
<tr><td class="shadl"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/shadow-bl.png" height="18" width="18" alt=""></td><td class="shadb"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/blank.gif" height="18" alt=""></td><td class="shadimg"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/border-rb.png" height="18" width="18" alt=""></td></tr></tbody></table>
</div><div class="inner"><table summary="content layout table"><tbody><tr><td class="bd" id="mc" colspan="2" rowspan="2"><table summary="content"><tbody><tr><td id="leftcontent"><div class="tiny">from small one page howto to huge articles all in one place</div><form method="post" action="http://www.linuxhowtos.org/search/"><div><input type="hidden" name="sessionid" value="5804457060111184">
<input type="hidden" name="content" value="-99">
<label for="fulltextsearch">search for: <br></label><input type="text" name="query" id="fulltextsearch" size="16" onblur="setTimeout(hidesuggest,750);" value="fulltextsearch">
<div id="suggestions">&nbsp;</div><br>search text in:<br>
<input type="checkbox" id="searchtype1" name="searchtype1" checked="checked"><label for="searchtype1">howtos</label><br><br><input type="checkbox" id="searchtype3" name="searchtype3" checked="checked"><label for="searchtype3">manpages</label></div></form>
<ul id="menu"><li><a href="http://www.linuxhowtos.org/Home/">Home</a><ul id="smenu1t1"><li><a href="http://www.linuxhowtos.org/News%20Archive/">News Archive</a></li><li><a href="http://www.linuxhowtos.org/linksfromexternalsites/">links from external sites</a></li></ul></li><li><a href="http://www.linuxhowtos.org/Network/">Network</a><ul id="smenu1t4"><li><a href="http://www.linuxhowtos.org/LDAP/">LDAP</a></li><li><a href="http://www.linuxhowtos.org/Infrared%20Devices/">Infrared Devices</a></li></ul></li><li><a href="http://www.linuxhowtos.org/Graphics/">Graphics</a><ul id="smenu1t7"><li><a href="http://www.linuxhowtos.org/Gimp/">Gimp</a><ul id="smenu2t8"><li><a href="http://www.linuxhowtos.org/creating%20an%20analog%20gauge%20image/">creating an analog gauge image</a></li></ul></li><li><a href="http://www.linuxhowtos.org/OpenGL/">OpenGL</a></li></ul></li><li><a href="http://www.linuxhowtos.org/Programming/">Programming</a><ul id="smenu1t11"><li><a href="http://www.linuxhowtos.org/C_C++/">C/C++</a></li><li><a href="http://www.linuxhowtos.org/CGI/">CGI</a></li><li><a href="http://www.linuxhowtos.org/Secure%20programming/">Secure programming</a></li></ul></li><li><a href="http://www.linuxhowtos.org/Misc/">Misc</a><ul id="smenu1t15"><li><a href="http://www.linuxhowtos.org/VI/">VI</a></li></ul></li><li><a href="http://www.linuxhowtos.org/System/">System</a><ul id="smenu1t17"><li><a href="http://www.linuxhowtos.org/PCMCIA/">PCMCIA</a></li><li><a href="http://www.linuxhowtos.org/Security/">Security</a></li><li><a href="http://www.linuxhowtos.org/Tips%20and%20Tricks/">Tips and Tricks</a></li><li><a href="http://www.linuxhowtos.org/Browser%20plugins/">Browser plugins</a></li></ul></li><li><a href="http://www.linuxhowtos.org/Help%20out/">Help out</a></li><li><a href="http://www.linuxhowtos.org/Distributions%20specific/">Distributions specific</a><ul id="smenu1t23"><li><a href="http://www.linuxhowtos.org/Gentoo/">Gentoo</a></li><li><a href="http://www.linuxhowtos.org/Fedora/">Fedora</a></li></ul></li><li><a href="http://www.linuxhowtos.org/contact/">contact</a></li><li><a href="http://www.linuxhowtos.org/interesting%20sites/">interesting sites</a><ul id="smenu1t27"><li><a href="http://www.linuxhowtos.org/german%20sites/">german sites</a></li></ul></li><li><a href="http://www.linuxhowtos.org/manpages/">manpages</a></li><li><a href="http://www.linuxhowtos.org/tools/">tools</a></li><li><a href="http://www.linuxhowtos.org/faq/">FAQ</a></li><li><a href="http://www.linuxhowtos.org/Sitemap/">Sitemap</a></li></ul><br><br><div id="otherlhto">Other .linuxhowtos.org sites:<a href="http://toolsntoys.linuxhowtos.org/">toolsntoys.linuxhowtos.org</a><br>
<a href="http://gentoo.linuxhowtos.org/">gentoo.linuxhowtos.org</a><br>
<!--              <a href="http://forums.linuxhowtos.org">forums.linuxhowtos.org</a><br />-->
</div><br><form action="http://www.linuxhowtos.org/" method="post"><div><input type="hidden" name="pollid" value="1">Poll<br>
Which kernel version do you use?<br>
<input type="radio" name="poll" id="answer1" value="1"><label for="answer1">&lt;2.0</label><br><input type="radio" name="poll" id="answer2" value="2"><label for="answer2">2.2</label><br><input type="radio" name="poll" id="answer3" value="3"><label for="answer3">2.4</label><br><input type="radio" name="poll" id="answer4" value="4"><label for="answer4">2.6</label><br><input type="radio" name="poll" id="answer5" value="5"><label for="answer5">other</label><br><input type="submit" value="vote"></div></form>
<a href="http://www.linuxhowtos.org/pollresults/">poll results</a><br><br>Last additions:<br><div><div class="leftpopup"><a href="http://www.linuxhowtos.org/Tips%20and%20Tricks/iotop.htm" tabindex="0">using iotop to find disk usage hogs</a><div><p>using iotop to find disk usage hogs</p><span>words:</span><p>887</p><span>views:</span><p>11361</p><span>userrating:</span><p>average rating: 1.8 (5 votes) (1=very good 6=terrible)</p></div></div></div><hr>May 25th. 2007:<div class="leftpopup"><div><span>Words</span><p>486</p><span>Views</span><p>27180</p></div><a href="http://www.linuxhowtos.org/News%20Archive/adblocker.htm" tabindex="1">why adblockers are bad</a></div><br><hr><div><div class="leftpopup"><a href="http://www.linuxhowtos.org/Security/coredumpvuln.htm" tabindex="2">Workaround and fixes for the current Core Dump Handling vulnerability affected kernels</a><div><p>Workaround and fixes for the current Core Dump Handling vulnerability affected kernels</p><span>words:</span><p>161</p><span>views:</span><p>16146</p><span>userrating:</span><p>average rating: 1.0 (2 votes) (1=very good 6=terrible)</p></div></div></div><hr>April, 26th. 2006:<div class="leftpopup"><div><span>Words</span><p>38</p><span>Views</span><p>12589</p></div><a href="http://www.linuxhowtos.org/News%20Archive/toolsntoys.htm" tabindex="3">New subdomain: toolsntoys.linuxhowtos.org</a></div><br><hr></td><td class="content" id="content"><!--messages--><div class="pdf"><a href="http://www.linuxhowtos.org/C_C++/socket.htm?print=208" title="Druckversion" tabindex="4"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/printer.gif" width="16" height="16" alt="Druckversion"></a>
 . <a href="http://www.linuxhowtos.org/C_C++/socket.pdf" title="pdf version"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/pdf.png" alt="pdf icon" width="16" height="16"></a></div>You are here: <a href="http://www.linuxhowtos.org/Programming/">Programming</a>-&gt;<a href="http://www.linuxhowtos.org/C_C++/">C/C++</a><br><br><a id="contentlink"><!-- google_ad_section_start --><h1>Sockets Tutorial</h1>This is a simple tutorial on using sockets for interprocess communication.   <p></p><p><br></p><h2>The client server model</h2>Most interprocess communication uses the <i>client server model</i>.  These terms refer to the two processes which will be communicating with each other.  One of the two processes, the <i>client</i>, connects to the other process, the <i>server</i>, typically to make a request for information.  A good analogy is a person who makes a phone call to another person.<p>Notice that the client needs to know of the existence of and the address of the server, but the server does not need to know the address of (or even the existence of) the client prior to the connection being established.</p><p>Notice also that once a connection is established, both sides can send and receive information.</p><p>The system calls for establishing a connection are somewhat different for the client and the server, but both involve the basic construct of a <i>socket</i>.<br>A socket is one end of an interprocess communication channel. The two processes   <br>each establish their own socket.</p><p>The steps involved in establishing a socket on the <i>client</i> side are as follows:<br></p></a><ol><a id="contentlink"></a><li><a id="contentlink"> Create a socket with the </a><a href="http://www.linuxhowtos.org/manpages/2/socket.htm">socket()</a> system call<br></li><li> Connect the socket to the address of the server using the <a href="http://www.linuxhowtos.org/manpages/2/connect.htm">connect()</a> system call<br></li><li> Send and receive data. There are a number of ways to do this, but the simplest is to use the <a href="http://www.linuxhowtos.org/manpages/2/read.htm">read()</a> and <a href="http://www.linuxhowtos.org/manpages/2/write.htm">write()</a> system calls.</li></ol><p></p><p>The steps involved in establishing a socket on the <i>server</i> side are as follows:<br></p><ol><li> Create a socket with the <a href="http://www.linuxhowtos.org/manpages/2/socket.htm">socket()</a> system call<br></li><li> Bind the socket to an address using the <a href="http://www.linuxhowtos.org/manpages/2/bind.htm">bind()</a> system call. For a server socket on the Internet, an address consists of a port number on the host machine.<br></li><li> Listen for connections with the <a href="http://www.linuxhowtos.org/manpages/2/listen.htm">listen()</a> system call<br></li><li> Accept a connection with the <a href="http://www.linuxhowtos.org/manpages/2/accept.htm">accept()</a> system call. This call typically blocks until a client connects with the server.<br></li><li> Send and receive data</li></ol><p></p><p></p><p><br></p><h3>Socket Types</h3><p>When a socket is created, the program has to specify the <i>address domain</i> and the <i> socket type</i>.  Two processes can communicate with each other only if their sockets are of the same type and in the same domain.</p><p>There are two widely used address domains, the <i>unix domain</i>, in which two processes which share a common file system communicate, and the <i>Internet domain</i>, in which two processes running on any two hosts on the Internet communicate.  Each of these has its own address format.</p><p>The address of a socket in the Unix domain is a character string which is basically an entry in the file system.</p><p>The address of a socket in the Internet domain consists of the Internet address of the host machine (every computer on the Internet has a unique 32 bit address, often referred to as its IP address).<br>In addition, each socket needs a port number on that host.<br>Port numbers are 16 bit unsigned integers. <br>The lower numbers are reserved in Unix for standard services.  For example, the port number for the FTP server is 21.  It is important that standard services be at the same port on all computers so that clients will know their addresses. <br>However, port numbers above 2000 are generally available.</p><p>There are two widely used socket types, <i>stream sockets</i>, and <i>datagram sockets</i>.  Stream sockets treat communications as a continuous stream of characters, while datagram sockets have to read entire messages at once. Each uses its own communciations protocol.</p><p>Stream sockets use TCP (Transmission Control Protocol), which is a reliable, stream oriented protocol, and datagram sockets use UDP (Unix Datagram Protocol), which is unreliable and message oriented.</p><p>The examples in this tutorial will use sockets in the Internet domain using the TCP protocol.</p><p></p><p><br></p><h3> Sample code</h3><p>C code for a very simple client and server are provided for you. These communicate using stream sockets in the Internet domain. The code is described in detail below.  However, before you read the descriptions and look at the code, you should compile and run the two programs to see what they do.</p><p><a href="http://www.linuxhowtos.org/data/6/server.c">server.c</a><br><a href="http://www.linuxhowtos.org/data/6/client.c">client.c</a></p><p>Download these into files called <code>server.c</code> and <code>client.c</code> and compile them separately into two executables called <code>server</code> and <code>client</code>.</p><p>They probably won't require any special compiling flags, but on some solaris systems you may need to link to the socket library by appending <code>-lsocket</code> to your compile command.</p><p>Ideally, you should run the client and the server on separate hosts on the Internet. Start the server first. Suppose the server is running on a machine called <code>cheerios</code>. When you run the server, you need to pass the port number in as an argument. You can choose any number between 2000 and 65535. If this port is already in use on that machine, the server will tell you this and exit. If this happens, just choose another port and try again. If the port is available, the server will block until it receives a connection from the client. Don't be alarmed if the server doesn't do anything;</p><p>It's not supposed to do anything until a connection is made.<br></p><p></p><p><br>Here is a typical command line:</p><pre>server 51717</pre><p>To run the client you need to pass in two arguments, the name of the host on which the server is running and the port number on which the server is listening for connections.</p><p>Here is the command line to connect to the server described above:</p><pre>client cheerios 51717</pre><br>The client will prompt you to enter a message. <br>If everything works correctly, the server will display your message on stdout, send an acknowledgement message to the client and terminate. <br>The client will print the acknowledgement message from the server and then terminate.<p>You can simulate this on a single machine by running the server in one window and the client in another. In this case, you can use the keyword <code>localhost</code> as the first argument to the client.</p><p>The server code uses a number of ugly programming constructs, and so we will go through it line by line.</p><hr><p></p><p></p><p><br><code>#include &lt;stdio.h&gt;</code><br></p><p></p><p><br>This header file contains declarations used in most input and output and is typically included in all C programs.</p><hr><p></p><p></p><p><br><code>#include &lt;sys/types.h&gt;</code><br></p><p></p><p><br>This header file contains definitions of a number of data types used in system calls.  These types are used in the next two include files.</p><hr><p></p><p></p><p><br><code>#include &lt;sys/socket.h&gt;</code><br></p><p></p><p><br>The header file socket.h includes a number of definitions of structures needed for sockets.</p><hr><p></p><p></p><p><br><code>#include &lt;netinet/in.h&gt;</code><br></p><p></p><p><br>The header file in.h contains constants and structures needed for internet domain addresses.<br></p><p></p><p></p><hr><p></p><p> void error(char *msg)</p><pre>{<br>  perror(msg);<br>  exit(1);<br>}</pre><br>This function is called when a system call fails. It displays a message about the error on <code>stderr</code> and then aborts the program. The <a href="http://www.linuxhowtos.org/data/6/perror.txt"> perror man page</a> gives more information.<hr><p></p><p></p><pre>int main(int argc, char *argv[])<br>{<br>  int sockfd, newsockfd, portno, clilen, n;</pre><br><code>sockfd</code> and <code>newsockfd</code> are file descriptors, i.e. array subscripts into the <a href="http://www.linuxhowtos.org/data/6/fd.txt">file descriptor table </a>.  These two variables store the values returned by the socket system call and the accept system call.<p><code>portno</code> stores the port number on which the server accepts connections.</p><p><code>clilen</code> stores the size of the address of the client. This is needed for the accept system call.</p><p><code>n</code> is the return value for the <code>read()</code> and <code>write()</code> calls; i.e. it contains the number of characters read or written.</p><hr><p></p><p></p><p></p><pre>char buffer[256];</pre><br>The server reads characters from the socket connection into this buffer.<hr><p></p><p></p><pre>struct sockaddr_in serv_addr, cli_addr;</pre><br>A <code>sockaddr_in</code> is a structure containing an internet address.  This structure is defined in <code>netinet/in.h</code>.<br><p></p><p><br>Here is the definition:<br></p><p></p><p></p><pre>struct sockaddr_in<br>{<br>  short   sin_family; /* must be AF_INET */<br>  u_short sin_port;<br>  struct  in_addr sin_addr;<br>  char    sin_zero[8]; /* Not used, must be zero */<br>};</pre><br>An <code>in_addr</code> structure, defined in the same header file, contains only one field, a unsigned long called <code>s_addr</code>.<p>The variable <code>serv_addr</code> will contain the address of the server, and <code>cli_addr</code> will contain the address of the client which connects to the server.</p><hr><p></p><p></p><p></p><pre> if (argc &lt; 2)<br> {<br>   fprintf(stderr,"ERROR, no port provided<br>");<br>   exit(1);<br> }</pre><br>The user needs to pass in the port number on which the server will accept connections as an argument.  This code displays an error message if the user fails to do this.<hr><p></p><p></p><pre>sockfd = socket(AF_INET, SOCK_STREAM, 0);<br>if (sockfd &lt; 0)<br>  error("ERROR opening socket");</pre><br>The <code>socket()</code> system call creates a new socket. It takes three arguments.  The first is the address domain of the socket.<p>Recall that there are two possible address domains, the unix domain for two processes which share a common file system, and the Internet domain for any two hosts on the Internet.  The symbol constant <code>AF_UNIX</code> is used for the former, and <code>AF_INET</code> for the latter (there are actually many other options which can be used here for specialized purposes).</p><p>The second argument is the type of socket.  Recall that there are two choices here, a stream socket in which characters are read in a continuous stream as if from a file or pipe, and a datagram socket, in which messages are read in chunks. The two symbolic constants are <code>SOCK_STREAM</code> and <code>SOCK_DGRAM</code>.</p><p>The third argument is the protocol. If this argument is zero (and it always should be except for unusual circumstances), the operating system will choose the most appropriate protocol. It will choose TCP for stream sockets and UDP for datagram sockets.</p><p>The socket system call returns an entry into the file descriptor table (i.e. a small integer). This value is used for all subsequent references to this socket. If the socket call fails, it returns -1.<br></p><p></p><p><br>In this case the program displays and error message and exits. However, this system call is unlikely to fail.</p><p>This is a simplified description of the socket call; there are numerous other choices for domains and types, but these are the most common. The <a href="http://www.linuxhowtos.org/data/6/socket.txt"> socket() man page</a> has more information.</p><hr><p></p><p></p><p></p><pre>bzero((char *) &amp;serv_addr, sizeof(serv_addr));</pre><br>The function <code>bzero()</code> sets all values in a buffer to zero. It takes two arguments, the first is a pointer to the buffer and the second is the size of the buffer. Thus, this line initializes <code>serv_addr</code> to zeros.   ----<pre>portno = atoi(argv[1]);</pre><br>The port number on which the server will listen for connections is passed in as an argument, and this statement uses the <code>atoi()</code> function to convert this from a string of digits to an integer.<hr><p></p><p></p><pre>serv_addr.sin_family = AF_INET;</pre><br>The variable <code>serv_addr</code> is a structure of type <code>struct sockaddr_in</code>.  This structure has four fields. The first field is <code>short sin_family</code>, which contains a code for the address family.  It should always be set to the symbolic constant <code>AF_INET</code>.<hr><p></p><p></p><pre>serv_addr.sin_port = htons(portno);</pre><br>The second field of <code>serv_addr</code> is <code>unsigned short sin_port</code>, which contain the port number. However, instead of simply copying the port number to this field, it is necessary to convert this to <a href="http://www.linuxhowtos.org/data/6/byteorder.html">network byte order</a> using the function <code> htons()</code> which converts a port number in host byte order to a port number in network byte order.<hr><p></p><p></p><pre>serv_addr.sin_addr.s_addr = INADDR_ANY;</pre><br>The third field of <code>sockaddr_in</code> is a structure of type <code>struct in_addr</code> which contains only a single field <code>unsigned long s_addr</code>.  This field contains the IP address of the host.  For server code, this will always be the IP address of the machine on which the server is running, and there is a symbolic constant <code>INADDR_ANY</code> which gets this address.<hr><p></p><p></p><pre>if (bind(sockfd, (struct sockaddr *) &amp;serv_addr,                   sizeof(serv_addr)) &lt; 0)<br>  error("ERROR on binding");</pre><br>The <code>bind()</code> system call binds a socket to an address, in this case the address of the current host and port number on which the server will run.  It takes three arguments, the socket file descriptor, the address to which is bound, and the size of the address to which it is bound. The second argument is a pointer to a structure of type <code>sockaddr</code>, but what is passed in is a structure of type <code>sockaddr_in</code>, and so this must be cast to   the correct type.  This can fail for a number of reasons, the most obvious being that this socket is already in use on this machine. The <a href="http://www.linuxhowtos.org/data/6/bind.txt"> bind() manual</a> has more information.<hr><p></p><p></p><pre>listen(sockfd,5);</pre><br>The <code>listen</code> system call allows the process to listen on the socket for connections.  The first argument is the socket file descriptor, and the second is the size of the backlog queue, i.e., the number of connections that can be waiting while the process is handling a particular connection.  This should be set to 5, the maximum size permitted by most systems. If the first argument is a valid socket, this call cannot fail, and so the code doesn't check for errors. The <a href="http://www.linuxhowtos.org/data/6/listen.txt"> listen() man page</a> has more information.<hr><p></p><p></p><pre>clilen = sizeof(cli_addr);<br>newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);<br>if (newsockfd &lt; 0)<br>  error("ERROR on accept");</pre><br>The <code>accept()</code> system call causes the process to block until a client connects to the server.  Thus, it wakes up the process when a connection from a client has been successfully established.  It returns a new file descriptor, and all communication on this connection should be done using the new file descriptor. The second argument is a reference pointer to the address of the client on the other end of the connection, and the third argument is the size of this structure. The <a href="http://www.linuxhowtos.org/data/6/accept.txt"> accept() man page</a> has more information.<hr><p></p><p></p><pre>bzero(buffer,256);<br>n = read(newsockfd,buffer,255);<br>if (n &lt; 0) error("ERROR reading from socket");<br>printf("Here is the message: %s<br>",buffer);</pre><br>Note that we would only get to this point after a client has successfully connected to our server.  This code initializes the buffer using the <code>bzero()</code> function, and then reads from the socket.  Note that the read call uses the new file descriptor, the one returned by <code>accept()</code>, not the original file descriptor returned by <code>socket()</code>.  Note also that the <code>read()</code> will block until there is something for it to read in the socket, i.e. after the client has executed a <code>write()</code>.<p>It will read either the total number of characters in the socket or 255, whichever is less, and return the number of characters read. The <a href="http://www.linuxhowtos.org/data/6/read.txt"> read() man page</a> has more information.</p><hr><p></p><p></p><p></p><pre>n = write(newsockfd,"I got your message",18);<br>if (n &lt; 0) error("ERROR writing to socket");</pre><br>Once a connection has been established, both ends can both read and write to the connection.  Naturally, everything written by the client will be read by the server, and everything written by the server will be read by the client.  This code simply writes a short message to the client.  The last argument of write is the size of the message. The <a href="http://www.linuxhowtos.org/data/6/write.txt"> write() man page</a>   has more information.<hr><p></p><p></p><pre>  return 0;<br>}</pre><br>This terminates main and thus the program. Since main was declared to be of type int as specified by the ascii standard, some compilers complain if it does not return anything.<p></p><p><br></p><h3> Client code </h3><br>As before, we will go through the program <code>client.c</code> line by line.   <pre>#include &lt;stdio.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt;<br>#include &lt;netinet/in.h&gt;<br>#include &lt;netdb.h&gt;</pre><br>The header files are the same as for the server with one addition. The file <code>netdb.h</code> defines the structure <code>hostent</code>, which will be used below.<hr><p></p><p></p><pre>void error(char *msg)<br>{<br>  perror(msg);<br>  exit(0);<br>}<br>int main(int argc, char *argv[])<br>{<br>  int sockfd, portno, n;<br>  struct sockaddr_in serv_addr;<br>  struct hostent *server;</pre><br>The <code>error()</code> function is identical to that in the server, as are the variables <code>sockfd, portno</code>, and <code>n</code>. The variable <code>serv_addr</code> will contain the address of the server to which we want to connect.  It is of type <a href="http://www.linuxhowtos.org/data/6/sockaddr">struct sockaddr_in</a>.<p>The variable <code>server</code> is a pointer to a structure of type <code>hostent</code>.  This structure is defined in the header file <code>netdb.h</code> as follows:</p><pre>struct  hostent<br>{<br>  char    *h_name;        /* official name of host */<br>  char    **h_aliases;    /* alias list */<br>  int     h_addrtype;     /* host address type */<br>  int     h_length;       /* length of address */<br>  char    **h_addr_list;  /* list of addresses from name server */<br>  #define h_addr  h_addr_list[0]  /* address, for backward compatiblity */<br>};</pre><br>It defines a host computer on the Internet. The members of this structure are:   <pre>h_name       Official name of the host.<br>h_aliases    A zero  terminated  array  of  alternate<br>             names for the host.<br>h_addrtype   The  type  of  address  being  returned;<br>             currently always AF_INET.<br>h_length     The length, in bytes, of the address.<br>h_addr_list  A pointer to a list of network addresses<br>             for the named host.  Host addresses are<br>             returned in network byte order.</pre><br>Note that <code>h_addr</code> is an alias for the first address in the array of network addresses.<hr><p></p><p></p><pre>char buffer[256];<br>if (argc &lt; 3)<br>{<br>  fprintf(stderr,"usage %s hostname port<br>", argv[0]);<br>  exit(0);<br>}<br>portno = atoi(argv[2]);<br>sockfd = socket(AF_INET, SOCK_STREAM, 0);<br>if (sockfd &lt; 0)<br>  error("ERROR opening socket");</pre><br>All of this code is the same as that in the server.<hr><p></p><p></p><pre>server = gethostbyname(argv[1]);<br>if (server == NULL)<br>{<br>  fprintf(stderr,"ERROR, no such host<br>");<br>  exit(0);<br>}</pre><br>The variable <code>argv</code>[1] contains the name of a host on the Internet, e.g. <code>cs.rpi.edu</code>. The function:<pre> struct hostent *gethostbyname(char *name)</pre><br>Takes such a name as an argument and returns a pointer to a <code>hostent</code> containing information about that host.<p>The field <code>char *h_addr</code> contains the IP address.<br></p><p></p><p><br>If this structure is NULL, the system could not locate a host with this name.   </p><p>In the old days, this function worked by searching a system file called <code>/etc/hosts</code> but with the explosive growth of the Internet, it became impossible for system administrators to keep this file current.  Thus, the mechanism by which this function works is complex, often involves querying large databases all around the country. The <a href="http://www.linuxhowtos.org/data/6/gethostbyname.txt"> gethostbyname() man page</a> has more information.</p><hr><p></p><p></p><p></p><pre>bzero((char *) &amp;serv_addr, sizeof(serv_addr));<br>serv_addr.sin_family = AF_INET;<br>bcopy((char *)server-&gt;h_addr,<br>      (char *)&amp;serv_addr.sin_addr.s_addr,<br>      server-&gt;h_length);<br>serv_addr.sin_port = htons(portno);</pre><br>This code sets the fields in <code>serv_addr</code>.  Much of it is the same as in the server.  However, because the field <code>server-&gt;h_addr</code> is a character string, we use the function:<pre>void bcopy(char *s1, char *s2, int length)</pre><br>which copies <code>length</code> bytes from <code>s1</code> to <code>s2</code>.   ----<pre>if (connect(sockfd,&amp;serv_addr,sizeof(serv_addr)) &lt; 0)<br>  error("ERROR connecting");</pre><br>The <code>connect</code> function is called by the client to establish a connection to the server.  It takes three arguments, the socket file descriptor, the address of the host to which it wants to connect (including the port number), and the size of this address.  This function returns 0 on success and -1 if it fails. The <a href="http://www.linuxhowtos.org/data/6/connect.txt">connect() man page</a> has more information.<p>Notice that the client needs to know the port number of the server, but it does not need to know its own port number.  This is typically assigned by the system when <code>connect</code> is called.</p><hr><p></p><p></p><p></p><pre>  printf("Please enter the message: ");<br>  bzero(buffer,256);<br>  fgets(buffer,255,stdin);<br>  n = write(sockfd,buffer,strlen(buffer));<br>  if (n &lt; 0)<br>    error("ERROR writing to socket");<br>  bzero(buffer,256);<br>  n = read(sockfd,buffer,255);<br>  if (n &lt; 0)<br>    error("ERROR reading from socket");<br>  printf("%s<br>",buffer);<br>  return 0;<br>}</pre><br>The remaining code should be fairly clear. It prompts the user to enter a message, uses <code>fgets</code> to read the message from stdin, writes the message to the socket, reads the reply from the socket, and displays this reply on the screen.<p></p><p><br></p><h2> Enhancements to the server code </h2><p>The sample server code above has the limitation that it only handles one connection, and then dies.  A "real world" server should run indefinitely and should have the capability of handling a number of simultaneous connections, each in its own process.  This is typically done by forking off a new process to handle each new connection.</p><p>The following code has a dummy function called <code>dostuff(int sockfd)</code>.<br></p><p></p><p><br>This function will handle the connection after it has been established and provide whatever services the client requests.  As we saw above, once a connection is established, both ends can use <code>read</code> and <code>write</code> to send information to the other end, and the details of the information passed back and forth do not concern us here.<br></p><p></p><p><br>To write a "real world" server, you would make essentially no changes to the main() function, and all of the code which provided the service would be in <code>dostuff()</code>.</p><p>To allow the server to handle multiple simultaneous connections, we make the following changes to the code:<br></p><ol><li> Put the accept statement and the following code in an infinite loop.<br></li><li> After a connection is established, call <code>fork()</code>#### to create a new process.<br></li><li> The child process will close <code>sockfd</code>#### and call <code>#dostuff</code>#####, passing the new socket file descriptor as an argument.  When the two processes have completed their conversation, as indicated by <code>dostuff()</code>#### returning, this process simply exits.<br></li><li> The parent process closes <code>newsockfd</code>####.  Because all of this code is in an infinite loop, it will return to the accept statement to wait for the next connection.</li></ol><p></p><p>Here is the code.</p><pre> while (1)<br> {<br>   newsockfd = accept(sockfd,<br>               (struct sockaddr *) &amp;cli_addr, &amp;clilen);<br>   if (newsockfd &lt; 0)<br>     error("ERROR on accept");<br>   pid = fork();<br>   if (pid &lt; 0)<br>     error("ERROR on fork");<br>   if (pid == 0)<br>   {<br>     close(sockfd);<br>     dostuff(newsockfd);<br>     exit(0);<br>   }<br>   else<br>     close(newsockfd);<br> } /* end of while */</pre><br><a href="http://www.linuxhowtos.org/data/6/server2.c">Click here</a> for a complete server program which includes this change.  This will run with the program client.c.<p></p><p><br></p><h3> The zombie problem </h3><p>The above code has a problem; if the parent runs for a long time and accepts many connections, each of these connections will create a zombie when the connection is terminated.  A zombie is a process which has terminated but but cannot be permitted to fully die because at some point in the future, the parent of the process might execute a <code>wait</code> and would want information about the death of the child. Zombies clog up the process table in the kernel, and so they should be prevented.  Unfortunately, the code which prevents zombies is not consistent across different architectures. When a child dies, it sends a SIGCHLD signal to its parent. On systems such as AIX, the following code in <code>main()</code> is all that is needed.</p><pre>signal(SIGCHLD,SIG_IGN);</pre><br>This says to ignore the SIGCHLD signal. However, on systems running SunOS, you have to use the following code:<pre>void *SigCatcher(int n)<br>{<br>  wait3(NULL,WNOHANG,NULL);<br>}<br>...<br>int main()<br>{<br>  ...<br>  signal(SIGCHLD,SigCatcher);<br>  ...</pre><br>The function <code>SigCatcher()</code> will be called whenever the parent receives a SIGCHLD signal (i.e. whenever a child dies).  This will in turn call <code>wait3</code> which will receive the signal. The WNOHANG flag is set, which causes this to be a non-blocking wait (one of my favorite <a href="http://rampages.onramp.net/~greid/oxymoron.htm"> oxymorons</a>).<p></p><p><br></p><h3> Alternative types of sockets </h3><p>This example showed a stream socket in the Internet domain.  This is the most common type of connection.  A second type of connection is a datagram socket.  You might want to use a datagram socket in cases where there is only one message being sent from the client to the server, and only one message being sent back. There are several differences between a datagram socket and a stream socket.<br></p><ol><li> Datagrams are unreliable, which means that if a packet of information gets lost somewhere in the Internet, the sender is not told (and of course the receiver does not know about the existence of the message).  In contrast, with a stream socket, the underlying TCP protocol will detect that a message was lost because it was not acknowledged, and it will be retransmitted without the process at either end knowing about this.<br></li><li> Message boundaries are preserved in datagram sockets. If the sender sends a datagram of 100 bytes, the receiver must read all 100 bytes at once.  This can be contrasted with a stream socket, where if the sender wrote a 100 byte message, the receiver could read it in two chunks of 50 bytes or 100 chunks of one byte.<br></li><li> The communication is done using special system calls <code>sendto()</code>#### and <code>receivefrom()</code>#### rather than the more generic <code>read()</code>#### and <code>write()</code>####.<br></li><li> There is a lot less overhead associated with a datagram socket because connections do not need to be established and broken down, and packets do not need to be acknowledged.  This is why datagram sockets are often used when the service to be provided is short, such as a time-of-day service.</li></ol><p></p><p><a href="http://www.linuxhowtos.org/data/6/server_udp.c">Click here</a> for the server code using a datagram socket.   </p><p><a href="http://www.linuxhowtos.org/data/6/client_udp.c">Click here</a> for the client code using a datagram socket.   </p><p>These two programs can be compiled and run in exactly the same way as the server and client using a stream socket.</p><p>Most of the server code is similar to the stream socket code.  Here are the differences.</p><pre>sock=socket(AF_INET, SOCK_DGRAM, 0);</pre><br>Note that when the socket is created, the second argument is the symbolic constant SOCK_DGRAM instead of SOCK_STREAM.  The protocol will be UDP, not TCP.   ----<pre>fromlen = sizeof(struct sockaddr_in);<br>while (1)<br>{<br>  n = recvfrom(sock,buf,1024,0,(struct sockaddr *)&amp;from,&amp;fromlen);<br>  if (n &lt; 0) error("recvfrom");</pre><br>Servers using datagram sockets do not use the <code>listen()</code> or the <code>accept()</code> system calls.  After a socket has been bound to an address, the program calls <code>recvfrom()</code> to read a message. This call will block until a message is received. The <code>recvfrom()</code> system call takes six arguments.  The first three are the same as those for the <code> read()</code> call, the socket file descriptor, the buffer into which the message will be read, and the maximum number of bytes.  The fourth argument is an integer argument for flags.  This is ordinarily set to zero.  The fifth argument is a pointer to a <a href="http://www.linuxhowtos.org/data/6/sockaddr">sockaddr_in structure</a>.  When the call returns, the values of this structure will have been filled in for the other end of the connection (the client). The size of this structure will be in the last argument, a pointer to an integer. This call returns the number of bytes in the message.  (or -1 on an error condition). The <a href="http://www.linuxhowtos.org/data/6/recvfrom.txt">recfrom() man page</a> has more information.<hr><p></p><p></p><pre>  n = sendto(sock,"Got your message<br>",17,<br>             0,(struct sockaddr *) &amp;from,fromlen);<br>  if (n  &lt; 0)<br>    error("sendto");<br>  }<br>}</pre><br>To send a datagram, the function <code>sendto()</code> is used. This also takes six arguments.  The first three are the same as for a <code>write()</code> call, the socket file descriptor, the buffer from which the message will be written, and the number of bytes to write.  The fourth argument is an int argument called flags, which is normally zero.  The fifth argument is a pointer to a <code>sockadd_in</code> structure.  This will contain the address to which the message will be sent.  Notice that in this case, since the server is replying to a message, the values of this structure were provided by the recvfrom call.  The last argument is the size of this structure.  Note that this is not a pointer to an int, but an int value itself.  The <a href="http://www.linuxhowtos.org/data/6/sendto.txt">sendto() man page</a> has more information.<p>The client code for a datagram socket client is the same as that for a stream socket with the following differences.<br></p><ul><li> the socket system call has SOCK_DGRAM instead of SOCK_STREAM as its second argument.<br></li><li> there is no <code>connect()</code>**** system call<br></li><li> instead of <code>read</code>**** and <code>write</code>****, the client uses <code> recvfrom</code>**** and <code> sendto </code>**** which are described in detail above.   </li></ul><p></p><p></p><p><br></p><h3> Sockets in the Unix Domain </h3><p>Here is the code for a client and server which communicate using a stream socket in the Unix domain.</p><p><a href="http://www.linuxhowtos.org/data/6/U_server.c">U_server.c</a><br></p><p></p><p><br><a href="http://www.linuxhowtos.org/data/6/U_client.c">U_client</a></p><p>The only difference between a socket in the Unix domain and a socket in the Internet domain is the form of the address.  Here is the address structure for a Unix Domain address, defined in <a href="http://www.linuxhowtos.org/data/6/un.h">the header file</a>.</p><pre>struct	sockaddr_un<br>{<br> short	sun_family;	/* AF_UNIX */<br> char	sun_path[108];	/* path name (gag) */<br>};</pre><br>The field <code>sun_path</code> has the form of a path name in the Unix file system.  This means that both client and server have to be running the same file system. Once a socket has been created, it remain until it is explicitly deleted, and its name will appear with the <code>ls</code> command, always with a size of zero.  Sockets in the Unix domain are virtually identical to named pipes (FIFOs).<p></p><p><br></p><h3> Designing servers </h3><p>There are a number of different ways to design servers.  These models are discussed in detail in a book by Douglas E. Comer and David L. Stevens entiteld <i>Internetworking with TCP/IP Volume III:Client Server Programming and Applications</i> published by <a href="http://www.prenhall.com/">Prentice Hall</a> in 1996. These are summarized here.</p><p><i>Concurrent, connection oriented servers</i><br></p><p></p><p><br>The typical server in the Internet domain creates a stream socket and forks off a process to handle each new connection that it receives. This model is appropriate for services which will do a good deal of reading and writing over an extended period of time, such as a telnet server or an ftp server.  This model has relatively high overhead, because forking off a new process is a time consuming operation, and because a stream socket which uses the TCP protocol has high kernel overhead, not only in establishing the connection but also in transmitting information.  However, once the connection has been established, data transmission is reliable in both directions.</p><p><i>Iterative, connectionless servers</i><br></p><p></p><p><br>Servers which provide only a single message to the client often do not involve forking, and often use a datagram socket rather than a stream socket.  Examples include a finger daemon or a timeofday server or an echo server (a server which merely echoes a message sent by the client).  These servers handle each message as it receives them in the same process.  There is much less  overhead with this type of server, but the communication is unreliable.  A request or a reply may get lost in the Internet, and there is no built-in mechanism to detect and handle this.</p><p><i>Single Process concurrent servers</i><br></p><p></p><p><br>A server which needs the capability of handling several clients simultaneous, but where each connection is I/O dominated (i.e. the server spends most of its time blocked waiting for a message from the client) is a candidate for a single process, concurrent server.  In this model, one process maintains a number of open connections, and listens at each for a message.  Whenever it gets a message from a client, it replies quickly and then listens for the next one. This type of service can be done   <br></p><p></p><p><br>with the <code>select</code> system call.</p><p></p><p></p><hr><strong>rate this article:</strong><br>current rating: average rating: 1.3 (4023 votes) (1=very good 6=terrible)<br>Your rating:<br><form action="./Linux Howtos  C C++ -  Sockets Tutorial_files/Linux Howtos  C C++ -  Sockets Tutorial.htm" method="get"><div><input type="radio" name="userrate" value="1">Very good (1)
<input type="radio" name="userrate" value="2">Good (2)
<input type="radio" name="userrate" value="3">ok (3)
<input type="radio" name="userrate" value="4">average (4)
<input type="radio" name="userrate" value="5">bad (5)
<input type="radio" name="userrate" value="6">terrible (6)
<input type="submit" value="submit your rating"></div></form><br><script type="text/javascript" src="./Linux Howtos  C C++ -  Sockets Tutorial_files/linux,howtos,socket,tcp,udp,c" ?showad="3"></script><div style="width:148px;height:50px;background:#0e252d url(http://www.sharethistag.com/img/sharethistagbutton.jpg);color:#000;padding:0;" onmouseout="off5259()"><div id="sharethistaglayer5259" style="position:absolute;display:none;width:150px;color:#fff;font:10px Arial,sans-serif;min-height:36px;background-color:#0e252d; margin:14px 0 0 0; padding:2px 5px 2px 5px;" onmouseover="on5259()"> Show other sites with the topic:<br><ul style="margin:0; padding:0;"><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/c" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- c</a></li><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/howtos" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- howtos</a></li><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/linux" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- linux</a></li><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/socket" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- socket</a></li><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/tcp" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- tcp</a></li><li style="margin:0;padding:0;"> <a href="http://www.sharethistag.com/tag/udp" style="display:block;font:10px Arial, sans-serif; color:#FFF; text-decoration:none;">- udp</a></li></ul></div><a href="http://www.sharethistag.com/" style="display:block;height:19px; width:150px;text-decoration:none;" onmouseover="on5259()">&nbsp;</a></div><a href="http://www.linuxhowtos.org/C_C++/">back</a><!-- google_ad_section_end --><br>Please read "<a href="http://www.linuxhowtos.org/News%20Archive/adblocker.htm">Why adblockers are bad</a>".<a href="http://www.servicekatastrophe-deutschland.de/freenetde/" style="display:none;">Ärger mit Freenet.de</a>
<br><br><br><br></td><td id="rightcontent"><!--            <div id="wikilogin" title="Edits you make while logged in will be assigned to that name. That means you get full credit for your contributions in the page history (when not logged in, the edits are just assigned to Anonymous."><form action="/" method="post"><div>to the <a href="http://forum.linuxhowtos.org/">forum</a>.<br /><label for="sitelogin">username</label>:<input type="text" name="sitelogin" id="sitelogin" size="6" value="username" /><br /><label for="sitepasswd">password</label>:<input type="password" name="sitepasswd" id="sitepasswd" size="6" /><br /><input type="submit" value="log in" /></div></form></div>--><!--              <script type="text/javascript" src="http://www.linuxhowtos.org:8080/i/1/ABC/1.js"></script>-->
<script type="text/javascript">google_ad_client = "pub-4309123515655559";  google_alternate_color = "CCCCCC"; google_ad_width = 120;  google_ad_height = 600; google_ad_format = "120x600_as"; google_ad_channel ="9997585796"; google_color_border = "000000";  google_color_text = "000000"; google_color_bg = "CCCCCC"; google_color_link = "0000FF"; google_color_url = "008000";document.write("<sc"+"ript type=\"text/javascript\" src=\"http://pagead2.googlesyndication.com/pagead/show_ads.js\"></sc"+"ript>");
</script><script type="text/javascript" src="./Linux Howtos  C C++ -  Sockets Tutorial_files/show_ads.js"></script><ins style="display:inline-table;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:120px"><ins id="aswift_0_anchor" style="display:block;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:120px"><iframe allowtransparency="true" frameborder="0" height="600" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+=&#39;.call&#39;;setTimeout(h,0)}else if(h.match){i+=&#39;.nav&#39;;w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" scrolling="no" vspace="0" width="120" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;"></iframe></ins></ins><div class="otherads">other Ads</div><div class="adbox"><a href="http://www.nachoben.com/">Stellenangebote</a><br>Stellenangebote<br>für Fach- und<br>Führungskräfte<br>
<span class="blink"><a href="http://www.nachoben.com/">www.nachoben.com</a></span><br></div>
<div class="otherads">Other free services</div><div class="adbox"><a href="http://tourl.org/">toURL.org</a><br>Shorten long<br>URLs to short<br>links like<br>http://tourl.org/2<br>
<span class="blink"><a href="http://tourl.org/">tourl.org</a></span><br></div><div class="sep">.</div>
<div class="adbox"><a href="http://www.feedcollector.org/">FeedCollector</a><br>Combine various newsfeeds to one customized webpage<br>
<span class="blink"><a href="http://www.feedcollector.org/">www.feedcollector.org</a></span><br></div><div class="sep">.</div>
<div class="adbox"><a href="http://www.reversednslookup.org/">Reverse DNS lookup</a><br>Find out which hostname(s)<br>resolve to a<br>given IP or other hostnames for the server<br>
<span class="blink"><a href="http://www.reversednslookup.org/">www.reversednslookup.org</a></span><br></div>
</td></tr></tbody></table></td><td class="shadt"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/shadow-tr.png" width="18" height="18" alt=""></td>
</tr><tr><td class="shadr"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/blank.gif" width="18" height="1" alt=""></td></tr>
<tr><td class="shadl"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/shadow-bl.png" width="18" height="18" alt=""></td><td class="shadb"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/blank.gif" width="18" height="18" alt=""></td><td class="shadimg"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/border-rb.png" height="18" width="18" alt=""></td></tr>
</tbody></table></div><div id="bottomline"><a href="http://www.linuxhowtos.org/news.rdf" title="rdf newsfeed"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/rdf.png" alt="rdf newsfeed" width="80" height="15"></a> |
<a href="http://www.linuxhowtos.org/news.rss" title="rss newsfeed"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/rss.png" alt="rss newsfeed" width="80" height="15"></a> |
<a href="http://www.linuxhowtos.org/news.xml" title="Atom newsfeed"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/atom.png" alt="Atom newsfeed" width="80" height="15"></a><br>
- Powered by <a href="http://www.leopardcms.com/"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/leopardcms.png" alt="LeopardCMS" width="80" height="15"></a> - Running on <a href="http://www.gentoo.org/"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/gentoo.png" alt="Gentoo" width="80" height="15"></a> -<br>
Copyright 2004-2010 S&amp;P Softwaredesign<br><a href="http://validator.w3.org/check?uri=referer"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/xhtml.png" alt="Valid XHTML1.1" width="80" height="15"></a> :
<a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/css.png" alt="Valid CSS" width="80" height="15"></a> : <a href="http://www.linuxhowtos.org/buttonmaker/index.php"><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/buttonmaker.png" alt="buttonmaker" width="80" height="15"></a><br>
- <a href="http://www.w3.org/WAI/WCAG1AAA-Conformance">Level Triple-A Conformance to Web Content Accessibility Guidelines 1.0</a> -<br>
- <a href="http://www.linuxhowtos.org/category17/">Copyright and legal notices</a> -<br>Time to create this page: 11.2 ms<br><img src="./Linux Howtos  C C++ -  Sockets Tutorial_files/output.jpg" alt="system status display" width="264" height="100"></div></div><script type="text/javascript">document.getElementById("fulltextsearch").onkeypress=chk;bodyloaded();</script>

</body></html>